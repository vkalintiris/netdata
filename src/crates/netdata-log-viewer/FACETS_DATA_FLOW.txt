FACETS SYSTEM DATA FLOW AND TRANSFORMATION PIPELINE
====================================================

1. DATA INGESTION STAGE
======================

   Application Input
       |
       v
   facets_add_key_value_length(key, value, len)
       |
       +----> Register/Create FACET_KEY (if not exists)
       |       - Hash field name with XXH3
       |       - Store in keys hashtable
       |
       +----> Store raw value pointer
       |       k->current_value.raw = value
       |       k->current_value.raw_len = len
       |
       v
   facets_key_check_value()
       |
       +----> Set FACET_KEY_VALUE_UPDATED flag
       |
       +----> [IF transform callback exists AND not view_only]
       |       - Copy raw to buffer
       |       - Call transform_cb(facets, buffer, FACETS_TRANSFORM_VALUE, data)
       |       - Set FACET_KEY_VALUE_COPIED flag
       |       - Buffer now contains canonical/indexed form
       |
       +----> [IF FTS enabled]
       |       - Copy to buffer if needed
       |       - Match against search pattern
       |       - Update query match counters
       |
       +----> [IF key has facet values enabled]
       |       - Get final value: facets_key_get_value(k)
       |         Returns: buffer if copied, else raw pointer
       |       - Hash the value with XXH3
       |       - FACET_VALUE_ADD_CURRENT_VALUE_TO_INDEX(k)
       |         Creates FACET_VALUE if new
       |       - Deduplicate in values hashtable
       |
       v
   Row State Updated


2. ROW COMPLETION STAGE (facets_row_finished)
==============================================

   for each facet key:
       |
       +----> [IF value was not provided in this row]
       |       - facets_key_set_empty_value()
       |       - Adds "-" (FACET_VALUE_UNSET) marker
       |       - Set FACET_KEY_VALUE_EMPTY flag
       |       - Add to empty_value index
       |
       +----> Increment row counter for this value
       |       v->rows_matching_facet_value++
       |
       +----> [IF histogram enabled]
       |       - Find time bucket for timestamp
       |       - Increment v->histogram[slot]
       |
       v
   Filtering Logic:
       |
       +----> Check FTS filter: REJECT if no match
       |
       +----> Check time range: REJECT if outside boundaries
       |
       +----> Check anchor boundaries: 
       |       Respect pagination direction (BACKWARD/FORWARD)
       |
       +----> Count: all required filters matched?
       |       Increment final_facet_value_counter
       |
       +----> [IF selected_keys == total_keys]
       |       - Update histogram for this value
       |       - If within anchor: add row to results
       |       - Row stored in doubly-linked list
       |
       v
   facets_reset_keys_with_value_and_row()
       - Clear all key states for next row
       - Reset query match counters
       - Reset severity to NORMAL
       - Cleanup bin_data


3. OUTPUT GENERATION STAGE (facets_report)
==========================================

   A. FACETS ARRAY (filter options)
      
      for each FACET_KEY with values enabled:
          |
          +----> for each FACET_VALUE in key:
          |       |
          |       +----> Skip if empty AND DONT_SEND_EMPTY_VALUE_FACETS
          |       |
          |       +----> Skip if unsampled or estimated (not in facets output)
          |       |
          |       +----> facets_key_value_transformed()
          |       |       - Copy value name to buffer
          |       |       [IF view-only transform]
          |       |           Call transform_cb(..., FACETS_TRANSFORM_FACET, ...)
          |       |       - Output: id, name, count, order
          |       |
          |       v
          |   Facet JSON:
          |   {
          |     "id": "value_id_or_hash",
          |     "name": "displayed_name",
          |     "count": N,
          |     "order": 0
          |   }
          |
          v
      Facets array complete


   B. COLUMNS DEFINITION
      
      Column 0: timestamp (RRDF_FIELD_TYPE_TIMESTAMP)
      Column 1: rowOptions (metadata)
      
      for each FACET_KEY:
          |
          +----> [Skip if HIDDEN]
          |
          +----> Determine visibility flags
          |       - Check VISIBLE, STICKY options
          |       - Check visible_keys pattern
          |       - Check FACETS_OPTION_ALL_FACETS_VISIBLE
          |
          +----> Determine filter capability
          |       - NEVER_FACET => no filter
          |       - Otherwise: FACET filter
          |
          +----> Add field definition
          |       - id: key name or hash
          |       - name: key name
          |       - type: STRING
          |       - visual: RICH or VALUE
          |       - transform: XML or NONE
          |
          v
      Columns complete


   C. DATA ROWS
      
      for each FACET_ROW in results:
          |
          +----> Output array:
          |       [
          |         timestamp_usec,
          |         { "severity": "normal|warning|..." },
          |         value1, value2, ..., valueN
          |       ]
          |
          |       for each FACET_KEY:
          |           |
          |           +----> [If dynamic callback]
          |           |       Call dynamic_cb() to generate value
          |           |
          |           +----> [If view-only transform]
          |           |       Call transform_cb(..., FACETS_TRANSFORM_DATA, ...)
          |           |
          |           +----> [Else output as-is from row.dict]
          |           |
          |           v
          |       Value output (null if empty)
          |
          v
      Data complete


   D. HISTOGRAM (if enabled)
      
      Key metrics:
          - Histogram key field
          - Time range: after_ut to before_ut
          - Slot width: calculated from range
          - Number of slots: min(range/width, 1000)
      
      for each FACET_VALUE for histogram key:
          |
          +----> facets_key_value_transformed()
          |       - For histogram display format
          |       - Applies FACETS_TRANSFORM_HISTOGRAM
          |
          +----> Output dimensions:
          |       - ids: array of value ids
          |       - names: array of transformed names
          |       - colors: UI colors
          |       - units: "events"
          |       - min, max, avg: statistics
          |
          +----> Output histogram data:
          |       for each time slot:
          |           [timestamp, [val1_count, val2_count, ...]]
          |
          v
      Histogram complete


4. SPECIAL VALUE HANDLING
=========================

   EMPTY VALUES: FACET_VALUE_UNSET = "-"
       - Set when facet key missing in row
       - empty=true flag
       - Used for counting missing data
       - Output in row data as null

   UNSAMPLED VALUES: FACET_VALUE_UNSAMPLED = "[unsampled]"
       - Set via facets_row_finished_unsampled()
       - unsampled=true flag
       - color="offline"
       - Indicates data was skipped by sampling algorithm
       - Shows in histogram as separate dimension

   ESTIMATED VALUES: FACET_VALUE_ESTIMATED = "[estimated]"
       - Set via facets_update_estimations()
       - estimated=true flag
       - color="generic"
       - Used for statistical extrapolation
       - Shows in histogram as separate dimension


5. TRANSFORMATION SCOPES
=========================

   FACETS_TRANSFORM_VALUE (Ingestion time)
       - Normal transformations only
       - Affects what gets indexed
       - Used for canonical form
       - Happens in facets_key_check_value()

   FACETS_TRANSFORM_FACET (Facet output)
       - View-only transformations only
       - Format for filter options display
       - Doesn't affect filtering

   FACETS_TRANSFORM_HISTOGRAM (Histogram output)
       - View-only transformations only
       - Format for histogram labels
       - Called for dimension names

   FACETS_TRANSFORM_DATA (Row output)
       - View-only transformations only
       - Format for table cell display
       - Called for row values

   FACETS_TRANSFORM_FACET_SORT (Facet sorting)
       - View-only transformations only
       - Format for comparison during sort
       - Used for ordering facet values


6. BUFFER LIFECYCLE
===================

   k->current_value.raw      Raw input pointer
       |
       v
   [IF transform needed]
       buffer_contents_replace(k->current_value.b, raw, len)
       Set FACET_KEY_VALUE_COPIED flag
       |
       v
   k->current_value.b        Transformed buffer
   
   Value retrieval:
       facets_key_get_value() returns buffer if copied, else raw
   
   Row storage:
       FACET_ROW_KEY_VALUE created on row finalization
       - tmp = facets_key_get_value(k)
       - tmp_len = facets_key_get_value_length(k)
       - Creates buffer: buffer_contents_replace(rkv->wb, tmp, tmp_len)
       - This is final storage for row


7. COUNTING LOGIC
=================

   rows_matching_facet_value
       Incremented for EACH row containing this value
       Counts: "How many rows had this value?"
   
   final_facet_value_counter
       Incremented only if:
       - All facet filters matched
       - (selected_keys >= total_keys - 1) AND
       - (This value counted by selected keys OR all keys selected)
       Counts: "How many rows match ALL filters and have this value?"


8. HASH-BASED ID ENCODING
==========================

   Input: 64-bit value
   Output: 11-character string using charset: A-Z . a-z _ 0-9
   
   Encoding: Each 6 bits -> 1 character
   Special values:
       - HASH_ZERO (0)                  -> Empty/unset
       - HASH_UNSAMPLED (UINT64_MAX-1) -> Unsampled marker
       - HASH_ESTIMATED (UINT64_MAX)    -> Estimated marker


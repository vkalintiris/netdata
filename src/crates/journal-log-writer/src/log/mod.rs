mod chain;
use chain::Chain;

mod config;
pub use config::{Config, RetentionPolicy, RotationPolicy};

use journal_core::error::{JournalError, Result};
use journal_core::file::mmap::MmapMut;
use journal_core::file::{JournalFile, JournalFileOptions, JournalWriter, load_boot_id};
use journal_registry::repository;
use std::path::{Path, PathBuf};
use std::time::{SystemTime, UNIX_EPOCH};

#[allow(unused_imports)]
use tracing::{debug, error, info, instrument, span, warn};

fn create_chain(path: &Path) -> Result<Chain> {
    let machine_id = journal_core::file::file::load_machine_id()?;

    if path.exists() && !path.is_dir() {
        return Err(JournalError::NotADirectory);
    }

    if path.to_str().is_none() {
        return Err(JournalError::InvalidFilename);
    }

    let path = PathBuf::from(path).join(machine_id.as_simple().to_string());
    if path.to_str().is_none() {
        return Err(JournalError::InvalidFilename);
    }

    std::fs::create_dir_all(&path)?;

    path.canonicalize()
        .map_err(|_| JournalError::NotADirectory)?;
    if path.to_str().is_none() {
        return Err(JournalError::InvalidFilename);
    }

    Chain::new(path, machine_id)
}

/// Tracks rotation state for size and count limits
struct RotationState {
    size: Option<(u64, u64)>,      // (max, current)
    count: Option<(usize, usize)>, // (max, current)
}

impl RotationState {
    fn new(rotation_policy: &RotationPolicy) -> Self {
        Self {
            size: rotation_policy.size_of_journal_file.map(|max| (max, 0)),
            count: rotation_policy.number_of_entries.map(|max| (max, 0)),
        }
    }

    fn should_rotate(&self) -> bool {
        self.size.is_some_and(|(max, current)| current >= max)
            || self.count.is_some_and(|(max, current)| current >= max)
    }

    fn update(&mut self, journal_writer: &JournalWriter) {
        if let Some((_, ref mut current)) = self.size {
            *current = journal_writer.current_file_size();
        }
        if let Some((_, ref mut current)) = self.count {
            *current += 1;
        }
    }

    fn reset(&mut self) {
        if let Some((_, ref mut current)) = self.size {
            *current = 0;
        }
        if let Some((_, ref mut current)) = self.count {
            *current = 0;
        }
    }
}

/// Groups a journal file and its writer together
pub struct ActiveFile {
    repository_file: repository::File,
    journal_file: JournalFile<MmapMut>,
    writer: JournalWriter,
}

impl ActiveFile {
    /// Creates a new journal file with the given parameters
    fn create(
        chain: &mut Chain,
        seqnum_id: uuid::Uuid,
        boot_id: uuid::Uuid,
        next_seqnum: u64,
        max_file_size: Option<u64>,
    ) -> Result<Self> {
        let head_seqnum = next_seqnum;
        let head_realtime = SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .unwrap_or_default()
            .as_micros() as u64;

        let repository_file = chain.create_file(seqnum_id, head_seqnum, head_realtime)?;

        let options = JournalFileOptions::new(chain.machine_id, boot_id, seqnum_id)
            .with_window_size(8 * 1024 * 1024)
            .with_optimized_buckets(None, max_file_size)
            .with_keyed_hash(true);

        let mut journal_file = JournalFile::create(&repository_file, options)?;
        let writer = JournalWriter::new(&mut journal_file, head_seqnum, boot_id)?;

        Ok(Self {
            repository_file,
            journal_file,
            writer,
        })
    }

    /// Creates a successor file, inheriting settings from this file
    fn rotate(self, chain: &mut Chain, max_file_size: Option<u64>) -> Result<Self> {
        let next_seqnum = self.writer.next_seqnum();
        let boot_id = self.writer.boot_id();

        let head_seqnum = next_seqnum;
        let head_realtime = SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .unwrap_or_default()
            .as_micros() as u64;

        let seqnum_id = uuid::Uuid::from_bytes(self.journal_file.journal_header_ref().seqnum_id);
        let repository_file = chain.create_file(seqnum_id, head_seqnum, head_realtime)?;

        let mut journal_file = self
            .journal_file
            .create_successor(&repository_file, max_file_size)?;
        let writer = JournalWriter::new(&mut journal_file, head_seqnum, boot_id)?;

        Ok(Self {
            repository_file,
            journal_file,
            writer,
        })
    }

    /// Writes a journal entry
    fn write_entry(&mut self, items: &[&[u8]], realtime: u64, monotonic: u64) -> Result<()> {
        self.writer
            .add_entry(&mut self.journal_file, items, realtime, monotonic)
    }

    /// Gets the current file size
    fn current_file_size(&self) -> u64 {
        self.writer.current_file_size()
    }
}

pub struct Log {
    chain: Chain,
    config: Config,
    active_file: Option<ActiveFile>,
    rotation_state: RotationState,
    boot_id: uuid::Uuid,
    seqnum_id: uuid::Uuid,
    current_seqnum: u64,
}

impl Log {
    /// Creates a new journal log.
    pub fn new(path: &Path, config: Config) -> Result<Self> {
        let chain = create_chain(path)?;

        let current_seqnum = chain.tail_seqnum()?;
        let boot_id = load_boot_id()?;
        let seqnum_id = uuid::Uuid::new_v4();
        let rotation_state = RotationState::new(&config.rotation_policy);

        Ok(Log {
            chain,
            config,
            active_file: None,
            rotation_state,
            boot_id,
            seqnum_id,
            current_seqnum,
        })
    }

    /// Writes a journal entry.
    pub fn write_entry(&mut self, items: &[&[u8]]) -> Result<()> {
        if items.is_empty() {
            return Ok(());
        }

        if self.should_rotate() {
            self.rotate()?;
        }

        let realtime = SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .unwrap_or_default()
            .as_micros() as u64;
        let monotonic = realtime;

        let active_file = self.active_file.as_mut().unwrap();
        active_file.write_entry(items, realtime, monotonic)?;

        self.rotation_state.update(&active_file.writer);
        self.current_seqnum += 1;

        Ok(())
    }

    /// Syncs all written data to disk, ensuring durability.
    ///
    /// This should be called after writing a batch of log entries to ensure
    /// they are persisted to disk before acknowledging the request.
    pub fn sync(&mut self) -> Result<()> {
        if let Some(active_file) = &mut self.active_file {
            active_file.journal_file.sync()?;
        }
        Ok(())
    }

    fn should_rotate(&self) -> bool {
        self.active_file.is_none() || self.rotation_state.should_rotate()
    }

    #[tracing::instrument(skip_all, fields(active_file))]
    fn rotate(&mut self) -> Result<()> {
        use journal_core::file::JournalState;

        // Update chain with current file size before rotating
        if let Some(active_file) = &self.active_file {
            self.chain.update_file_size(
                &active_file.repository_file,
                active_file.current_file_size(),
            );
        }

        // Respect retention policy
        self.chain.retain(&self.config.retention_policy)?;

        // Create new file (either initial or rotated)
        let max_file_size = self.config.rotation_policy.size_of_journal_file;
        let new_file = if let Some(mut old_file) = self.active_file.take() {
            // Set the old file's state to ARCHIVED before creating successor
            old_file.journal_file.journal_header_mut().state = JournalState::Archived as u8;
            old_file.journal_file.sync()?;

            old_file.rotate(&mut self.chain, max_file_size)?
        } else {
            ActiveFile::create(
                &mut self.chain,
                self.seqnum_id,
                self.boot_id,
                self.current_seqnum + 1,
                max_file_size,
            )?
        };

        tracing::Span::current().record("new_file", new_file.repository_file.path());

        self.active_file = Some(new_file);
        self.rotation_state.reset();

        Ok(())
    }

    /// Writes a journal entry from a serializable value.
    ///
    /// This method serializes the value to JSON, flattens it, and writes it to the journal.
    /// The flattened structure converts nested JSON into KEY=VALUE pairs suitable for journal entries.
    ///
    /// # Example
    ///
    /// ```no_run
    /// use serde::Serialize;
    /// use journal::log::{Log, Config};
    /// use std::path::Path;
    ///
    /// #[derive(Serialize)]
    /// struct LogEntry {
    ///     message: String,
    ///     level: String,
    ///     user: User,
    /// }
    ///
    /// #[derive(Serialize)]
    /// struct User {
    ///     id: u64,
    ///     name: String,
    /// }
    ///
    /// # fn main() -> Result<(), Box<dyn std::error::Error>> {
    /// let mut log = Log::new(Path::new("/var/log/journal"), Config::default())?;
    ///
    /// let entry = LogEntry {
    ///     message: "User logged in".to_string(),
    ///     level: "INFO".to_string(),
    ///     user: User {
    ///         id: 42,
    ///         name: "alice".to_string(),
    ///     },
    /// };
    ///
    /// // This will write fields like:
    /// // MESSAGE=User logged in
    /// // LEVEL=INFO
    /// // USER_ID=42
    /// // USER_NAME=alice
    /// log.write_structured(&entry)?;
    /// # Ok(())
    /// # }
    /// ```
    #[cfg(feature = "serde-api")]
    pub fn write_structured<T: serde::Serialize>(&mut self, value: &T) -> Result<()> {
        use flatten_serde_json::flatten;

        // Serialize to JSON value
        let json_value = serde_json::to_value(value)
            .map_err(|_| JournalError::InvalidField)?;

        // Flatten the JSON structure - requires a JSON object (Map)
        let flattened = if let serde_json::Value::Object(map) = json_value {
            flatten(&map)
        } else {
            // If not an object, return error
            return Err(JournalError::InvalidField);
        };

        // Convert to journal field format (KEY=VALUE)
        let mut fields: Vec<Vec<u8>> = Vec::with_capacity(flattened.len());

        for (key, value) in flattened.iter() {
            // Convert key to uppercase and replace dots with underscores
            // (journal convention)
            let journal_key = key.to_uppercase().replace('.', "_");

            // Format as KEY=VALUE
            let field = match value {
                serde_json::Value::String(s) => {
                    format!("{}={}", journal_key, s)
                }
                serde_json::Value::Number(n) => {
                    format!("{}={}", journal_key, n)
                }
                serde_json::Value::Bool(b) => {
                    format!("{}={}", journal_key, if *b { "true" } else { "false" })
                }
                serde_json::Value::Null => {
                    format!("{}=", journal_key)
                }
                // Arrays and objects should be flattened already, but just in case
                _ => {
                    format!("{}={}", journal_key, value)
                }
            };

            fields.push(field.into_bytes());
        }

        // Convert Vec<Vec<u8>> to Vec<&[u8]> for write_entry
        let field_refs: Vec<&[u8]> = fields.iter().map(|f| f.as_slice()).collect();

        self.write_entry(&field_refs)
    }
}
